% Compte rendu TP : Résolution d'équations non linéaires
% ESIR - Université de Rennes
% CUPGE1 - MATH-S2
%
% Auteurs :
% - Balthazar GIROT
% - Romain COURAUD

% Packages ------------------------------------------------------------------
\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[switch, modulo]{lineno}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage[euler]{textgreek}
\usepackage{siunitx}
\usepackage[font=scriptsize]{caption}
\usepackage{multicol}
\usepackage[dvipsnames]{xcolor}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{calc}
\usepackage{setspace}
\usepackage{fancyvrb}
\usepackage{tabularx}
\usepackage{float}


\hypersetup{    % Remove default hyperlink style
    pdfborder=0 0 0,
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue
}

\lstset{
    language=Matlab,
    basicstyle=\ttfamily,
    showstringspaces=false,
    breaklines=true,
    frame=single,
}

\renewcommand{\lstlistingname}{Code}


\lstset{    % Code snippet settings
    language=R,
    basicstyle=\scriptsize\ttfamily,
    commentstyle=\ttfamily\color{red},
    numbers=left,
    numberstyle=\ttfamily\color{blue}\footnotesize,
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    title=\lstname,
    escapeinside={},
    keywordstyle={},
    morekeywords={}
    }

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\title{Compte rendu TP MATH-S2}

% Document ------------------------------------------------------------------
\begin{document}
\pagestyle{plain}


% Page 1 ------------------------------------------------------------------
\newgeometry{left=2.5cm, right=2.5cm, top=3.5cm, bottom=2.5cm}
\begin{titlepage}
\begin{center}

\textsc{\LARGE Université de Rennes - ESIR}\\[1cm]
% side by side logos
\begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[height=2.2cm, keepaspectratio]{logo-univ-de-rennes.png}
\end{minipage}\hfill
\begin{minipage}{0.45\textwidth}
    \centering
    \includegraphics[height=2.2cm, keepaspectratio]{logo-esir.png}
\end{minipage}\\[3cm]

\textsc{\Large Module MATH-S2 : Mathématiques}\\[0.5cm]
\textsc{\large CUPGE1 2022/2023 - Groupe 2}\\[1cm]

\HRule\\[0.4cm]
{\huge \textbf{Compte rendu de TP : Résolution d'équations non linéaires}}\\[0.15cm]
\HRule\\[3cm]


{\large \emph{Auteurs:}\\
- Romain \textsc{COURAUD}\\
- Balthazar \textsc{GIROT}}

\vfill
21 mai 2023
\end{center}
\end{titlepage}
\restoregeometry
\newgeometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}


% Page 2 ------------------------------------------------------------------
\newpage
\thispagestyle{empty}
\setcounter{page}{0}

\tableofcontents

\vfill
\noindent
\textbf{Nous attestons sur l'honneur que le contenu de ce document est original et est issu de nos réflexions personnelles.} Toutes les sources d'informations utilisées et les citations aux auteurs on été mentionnées conformément aux usages en vigueur et répertoriées dans la partie \hyperref[ref:Références]{"Références"}.

% Intro -----------------------------------------------------------------
\newpage

\section{Introduction}
\noindent L'objectif de ce TP de Mathématiques était, dans un premier temps de trouver la racine du polynôme $P(x) = x^3 + 4x^2 -10$ se trouvant dans l'intervalle $[0,5]$ à l'aide de plusieurs méthodes algorithmiques de recherche de zéro d'une fonction. Puis dans un second temps, de comparer ces différentes méthodes selon plusieurs critères.\\

\noindent Ainsi, nous avons construit et implémenté des algorithmes sous \href{https://www.mathworks.com/products/matlab.html}{MATLAB} et \href{https://octave.org/}{Octave} à partir des méthodes suivantes :
\begin{itemize}
    \item \hyperref[ref:dichotomie]{Méthode de la dichotomie}
    \item \hyperref[ref:trichotomie]{Méthode de la trichotomie}
    \item \hyperref[ref:pt-fixe]{Méthode du point fixe}
    \item \hyperref[ref:newton]{Méthode de Newton}
    \item \hyperref[ref:sécante]{Méthode de la sécante}
    \item \hyperref[ref:fausse-position]{Méthode de la fausse position}\\
\end{itemize}
\noindent Ces méthodes permettent toutes d'approcher le zéro d'une fonction, avec toutefois des performances différentes. Afin de les comparer, nous nous baserons sur 3 critères principaux : le \textbf{nombre d'itérations} requises pour approcher le zéro, la \textbf{vitesse moyenne} d'exécution de l'algorithme et \textbf{l'erreur} de l'approximation.\\

\noindent Rechercher la racine d'une fonction polynomiale revient à résoudre une équation non linéaire. Ainsi, les algorithmes présentés dans ce compte rendu de TP fonctionneront pour la recherche de zéro de toute fonction non linéaire.\\ 

\noindent L'intérêt principal des méthodes algorithmiques de recherche de zéro est d'offrir une approximation rapide et précise des racines d'une fonction dont il n'existe pas de solution analytique connue.\\

\noindent Les algorithmes présentés sont cependant dépendants de plusieurs facteurs. Tout d'abord, leur efficacité dépend fortement des conditions initiales. Dans ce TP, nous sélectionnerons les conditions initiales de manière à optimiser la convergence des algorithmes, choix que nous détaillerons pour chaque méthode. De plus, la vitesse d'exécution est dépendante – certes faiblement – des capacités de la machine sur laquelle sont effectués les tests. De ce fait, afin de comparer de façon significative les méthodes, tous les tests de vitesse présentés dans ce compte rendu ont été effectués sur la même machine.


% Méthodes et matériel ---------------------------------------------------
\newpage
\section{Méthodes et matériels}
\noindent Dans cette section, nous présenterons les méthodes étudiées et leur mise en oeuvre sous forme d'algorithme en pseudo-code. Vous retrouverez les fonctions codées en langage \href{https://www.mathworks.com/products/matlab.html}{MATLAB} dans le fichier .zip fourni avec ce compte-rendu, ou bien en suivant \href{https://github.com/taupz/tp_matlab}{\underline{ce lien}} si vous n'avez pas accès au dossier.\\

\noindent Chaque fonction présentée prend en paramètres les informations nécessaires à la méthode qu'elle implémente et un handle \texttt{fun} représentant la fonction dont on cherche la racine. Cela permet de tester les algoritmes pour différentes fonctions. Elles renverront la valeur approchée du zéro qu'elles ont obtenu, le nombre d'itérations nécessaires pour l'atteindre et l'erreur par rapport au zéro réel de fonction (calculé soit à la main, soit avec \texttt{roots}, une méthode native de matlab renvoyant les racines d'un polynôme). \\
\noindent Afin de les étudier, nous récupérerons les informations (valeur approchée, nombre d'itérations, erreur relative et temps d'exécution moyen sur 100 exécutions) de chaque méthode de la façon suivante (codée en MATLAB) :\\

\begin{lstlisting}[caption={Récupération des données d'une méthode}]
[dichotomic_value, nbIterDichotomie, errDichotomie] = dichotomic_func(fun , 0, 5, 10^-3, 100, trueValue);

total_time = 0;
for i = 1:100
    t_start = clock;
    dichotomic_func(fun, 0, 5, 10^-3, 100, trueValue);
    t_end = clock;
    exec_time = etime(t_end, t_start);
    total_time = total_time + exec_time;
end
averageTimeDichotomie = total_time/100;

disp(['Zero approche par dichotomie : ' num2str(dichotomic_value)]);
disp(['Erreur  : ' num2str(errDichotomie)]);
disp(['Nombre d iterations : ' num2str(nbIterDichotomie)]);
disp(['Temps moyen sur 100 executions : ' num2str(averageTimeDichotomie) 's' char(10)]);
\end{lstlisting}
Il est à noter que par souci de simplicité, nous considérerons que toutes les fonctions étudiées admettent un zéro.\\
Une fois ces données récupérées, nous pourrons les comparer et les analyser (cf. \hyperref[ref:resultats]{Résultats} et \hyperref[ref:discussions]{Discussions}).\\


% ===== Dichotomie =====
\subsection{Méthode de la dichotomie}
\label{ref:dichotomie}
\noindent La méthode de la dichotomie est un algorithme de recherche d'un zéro d'une fonction. Elle implique de diviser successivement un intervalle en deux sous-intervalles et en conservant le sous-intervalle contenant la racine de la fonction. Après un certain nombre de division, l'algorithme converge vers le zéro exacte de la fonction.\\
Pour implémenter notre algorithme, nous considérerons une fonction $f$ continue sur $[a,b]$ telle que $f(a)$ et $f(b)$ sont de signe opposés et non nuls. D'après le théorème des valeurs intermédiaires, il existe un point $c$ tel que $f(x) = 0$, qui correspond à notre racine. À chaque itération, nous allons considérer le milieu $c$ de l'intervalle $[a,b]$ comme une approximation du zéro de la fonction, puis déterminer si le zéro est dans $[a,c]$ ou dans $[c,b]$ pour réitérer la recherche dans ce nouvel intervalle contenant le zéro.\\
Ainsi, on peut écrire l'algorithme de dichotomie selon ce pseudo-code :
\begin{verbatim}
Entrée : fun, a, b, tol, iterMax, trueValue
Sortie: approximation de la racine, nombre d'itérations, erreur relative
Step 1 : i ← 1
Step 2 : TANT QUE i < iterMax ET |b - a| > tol FAIRE
Step 3 :    i ← i + 1
Step 4 :    c ← (a + b)/2
Step 5 :    fc ← fun(c)
Step 6 :    SI fc = 0
Step 7 :        BREAK
Step 8 :    FIN SI
Step 9 :    SI fun(a) * fc < 0
Step 10 :       b ← c
Step 11 :   SINON
Step 12 :       a ← c
Step 13 :   FIN SI
Step 14 : FIN TANT QUE
Step 15 : xfinal ← c
Step 16 : err ← |xfinal - trueValue|
\end{verbatim}

\noindent Après avoir utilisé cet algorithme pour trouver le zéro (connu comme étant environ $1,36523$) de la fonction $f(x) = x^3 + 4x^2 -10$, sur l'intervalle $[0,5]$ avec pour tolérance $10^{-3}$ et en limitant les itérations à $100$, nous obtenons :
\begin{itemize}
    \item Approximation de la racine : $1,3654$
    \item Nombre d'itérations : $13$
    \item Puissance de l'erreur : $10^{-4}$
    \item Temps moyen d'exécution (sur 100 exécutions) : $0,324$ ms
\end{itemize}
Nous pouvons donc en conclure que l'algorithme converge bien vers une approximation de la racine de $f$.

% ===== Trichotomie =====
\subsection{Méthode de la trichotomie}
\label{ref:trichotomie}
\noindent La méthode de la trichotomie utilise un fonctionnement similaire à celui de la dichotomie. En effet, au lieu de diviser l'intervalle par 2, elle implique un division en 3 sous-intervalles. De la même façon que pour la dichotomie, on choisit parmi ces trois sous-intervalles celui qui contient le zéro et on réitère la méthode, jusqu'à converger vers le zéro réel de la fonction.\\
Ainsi, on peut écrire l'algorithme de trichotomie selon ce pseudo-code :
\begin{verbatim}
Entrée : fun, a, b, tol, iterMax, trueValue
Sortie: approximation de la racine, nombre d'itérations, erreur relative
Step 1 : i ← 1
Step 2 : TANT QUE i < iterMax ET |b - a| > tol FAIRE
Step 3 :    i ← i + 1
Step 4 :    c1 ← (a + b)/3
Step 5 :    c2 ← 2*(a + b)/3
Step 6 :    fc1 ← fun(c1)
Step 7 :    fc2 ← fun(c2)
Step 8 :    SI fc1 = 0
Step 9 :        xfinal ← c1
Step 10 :       err = 0
Step 11 :       EXIT
Step 12 :   SINON SI fc2 = 0
Step 13 :       xfinal ← c2
Step 14 :       err = 0
Step 15 :       EXIT
Step 16 :   FIN SI
Step 17 :   SI fun(a) * fc1 < 0
Step 18 :       b ← c1
Step 19 :   SINON SI fun(a) * fc2 < 0
Step 20 :       a ← c1
Step 21 :       b ← c2
Step 22 :   SINON
Step 23 :       a ← c2
Step 24 :   FIN SI
Step 25 : FIN TANT QUE
Step 26 : xfinal ← (a + b)/2
Step 27 : err ← |xfinal - trueValue|
\end{verbatim}
\noindent Après avoir utilisé cet algorithme pour trouver le zéro (connu comme étant environ $1,36523$) de la fonction $f(x) = x^3 + 4x^2 -10$, sur l'intervalle $[0,5]$ avec pour tolérance $10^{-3}$ et en limitant les itérations à $100$, nous obtenons :
\begin{itemize}
    \item Approximation de la racine : $1,3653$
    \item Nombre d'itérations : $8$
    \item Puissance de l'erreur : $10^{-5}$
    \item Temps moyen d'exécution (sur 100 exécutions) : $0,285$ ms
\end{itemize}
Nous pouvons donc en conclure que l'algorithme converge bien vers une approximation de la racine de $f$.


% ===== Point fixe =====
\subsection{Méthode du point fixe}
\label{ref:pt-fixe}
\noindent La méthode du point fixe repose sur la notion de point fixe. Soit $f$ une application d'un ensemble $E$ dans lui-même, on dit qu'un élément $x$ de $E$ est un point fixe de $f$ si $f(x) = x$.\\
Nous utiliserons la méthode du point fixe pour calculer une approximation de la racine d'une fonction $f$ donnée. Toutefois, pour assurer la convergence de l'algorithme, il est nécessaire que la fonction étudiée respecte des conditions :
\begin{itemize}
    \item \underline{D'existence :} Si $g$ est une fonction continue sur $[a,b]$ et si $g(x)\in[a,b]$, alors $g$ possède au moins un point fixe dans $[a,b]$.
    \item \underline{D'unicité :} Si en outre $g$ est dérivable sur $[a,b]$ et s'il existe une constante $K\in[0,1[$ telle que $|g'(x)|\leq K$ pour tout $x\in[a,b]$, alors ce point fixe de $[a,b]$ est unique.
\end{itemize}
Nous choisirons donc des fonctions pouvant être utilisées dans l'algorithme du point fixe telles que :
\begin{multicols}{2}
\begin{itemize}
    \item[$\bullet$] $f_1(x)=x^3+4x^2-10$
    \item[$\bullet$] $f_2(x)=x^4+2x^2-x-3$
    \item[$\bullet$] $f_3(x)=6x^3-x- 1$
    \item[$\bullet$] $f_4(x)=3x^5+x^2-2x$
\end{itemize}
\end{multicols}
\noindent Pour résoudre l'équation $f(x)=0$, on fait intervenir une fonction $g$ telle que si $p$ est la solution de l'équation $f(x)=0$, alors $g(p) = p$, puis nous déterminerons le point fixe de cette fonction $g$.\\
Pour cela, si $g$ vérifie bien les conditions énoncées précédemment, on considère la suite $u_n+1=g(u_n)$. Si $(u_n)$ converge vers un élément $l$ , alors $l$ est un point fixe de $g$. Nous utiliserons cette propriété pour déterminer le point fixe de $g$, et par extension, la racine de $f$\\
Par exemple, associons une fonction $g_n$ à chaque fonction $f_n$ listé précédemment telle que $f_n(p)=0 \iff g_n(p)=p$ :
\begin{multicols}{2}
\begin{itemize}
    \item[$\bullet$] $g_1(x)=\frac{\sqrt{10-x^3}}{2}$
    \item[$\bullet$] $g_2(x)=(3 + x - 2x^2)^{1/4}$
    \item[$\bullet$] $g_3(x)=(\frac{1}{6}   + \frac{1}{6}x)^{1/3}$
    \item[$\bullet$] $g_4(x)=(-\frac{1}{3}x+\frac{2}{3}x)^{1/5}$
\end{itemize}
\end{multicols}
\noindent Avec toutes ces informations, on peut écrire l'algorithme du point fixe selon ce pseudo-code en prenant \texttt{fun} la fonction dont on cherche le point fixe :
\begin{verbatim}
Entrée : fun, p0, tol, iterMax, trueValue
Sortie: approximation de la racine, nombre d'itérations, erreur relative
Step 1 : i ← 1
Step 2 : x ← p0
Step 3 : TANT QUE i < iterMax FAIRE
Step 4 :    newX ← fun(x)
Step 5 :    SI |newX - x| < tol
Step 6 :        BREAK
Step 7 :    FIN SI
Step 8 :    i ← i + 1
Step 9 :    x ← newX
Step 10 : FIN TANT QUE
Step 11 : xfinal ← x
Step 12 : err ← |xfinal - trueValue|
\end{verbatim}
\noindent Après avoir utilisé cet algorithme pour trouver le zéro (connu comme étant environ $1,36523$) de la fonction $f(x) = x^3 + 4x^2 -10$, avec pour fonction associée $g_1(x)=\frac{\sqrt{10-x^3}}{2}$ dont on cherche le point fixe, en prenant $p_0=1$ avec pour tolérance $10^{-3}$ et en limitant les itérations à $100$, nous obtenons :
\begin{itemize}
    \item Approximation de la racine : $1,3654$
    \item Nombre d'itérations : $10$
    \item Puissance de l'erreur : $10^{-4}$
    \item Temps moyen d'exécution (sur 100 exécutions) : $0,439$ ms
\end{itemize}
Nous pouvons donc en conclure que l'algorithme converge bien vers une approximation de la racine de $f$.


% ===== Newton =====
\subsection{Méthode de Newton}
\label{ref:newton}
\noindent La méthode de Newton est une méthode itérative de recherche de zéro. Elle se base sur l'approximation d'une fonction par une tangente, et utilise cette tangente pour estimer la racine. Pour cela, on choisit une valeur initiale $p_0$ si possible relativement proche de la racine, puis on estime la racine de la fonction $f$ en calculant $p_1=p_0-\frac{f(p_0)}{f'(p_0)}$. On réitère l'opération en calculant $p_2$ à partir de $p_1$. On peut l'écrire sous la forme d'une suite $(U_n)$ de terme initial $u_0$ définir par $u_{n+1}=u_n-\frac{f(u_n)}{f'(u_n)}$.\\
Ainsi, on peut écrire l'algorithme de la méthode de Newton selon ce pseudo-code :
\begin{verbatim}
Entrée : fun, deriv, p0, tol, iterMax, trueValue
Sortie: approximation de la racine, nombre d'itérations, erreur relative
Step 1 : i ← 1
Step 2 : x ← p0
Step 3 : TANT QUE i < iterMax ET |fun(x)| > tol FAIRE
Step 4 :    i ← i + 1
Step 5 :    x = x - fun(x)/deriv(x)
Step 6 : FIN TANT QUE
Step 7 : xfinal ← x
Step 8 : err ← |xfinal - trueValue|
\end{verbatim}
Par souci de simplicité et d'accessibilité, nous dériverons "à la main" la fonction \texttt{fun} pour obtenir \texttt{deriv}. Il est possible en MATLAB de dériver un handle tel que \texttt{fun} mais cela nécessite un package non natif.\\

\noindent Après avoir utilisé cet algorithme pour trouver le zéro (connu comme étant environ $1,36523$) de la fonction $f(x) = x^3 + 4x^2 -10$, de dérivée $f'(x)=3x^2+8x$, en prenant $p_0=5$, avec pour tolérance $10^{-3}$ et en limitant les itérations à $100$, nous obtenons :
\begin{itemize}
    \item Approximation de la racine : $1,3653$
    \item Nombre d'itérations : $5$
    \item Puissance de l'erreur : $10^{-5}$
    \item Temps moyen d'exécution (sur 100 exécutions) : $0,183$ ms
\end{itemize}
Nous pouvons donc en conclure que l'algorithme converge bien vers une approximation de la racine de $f$.

% ===== Sécante =====
\subsection{Méthode de la sécante}
\label{ref:sécante}
\noindent La méthode de la sécante est une méthode de recherche de zéro d'une fonction qui est relativement similaire à celle de Newton dans son expression. On considère deux points $x_0$ et $x_1$ si possible relativement proches du zéro de la fonction $f$. On trace un segment reliant $f(x_0)$ et $f(x_1)$, et l'intersection entre ce point $x_0$ l'axe de abscisses constituera l'approximation du zéro de $f$. Ce point a pour abscisse : $x_2 = x_1 - \frac{x_1-x_0}{f(x_1)-f(x_0)}$. De ce fait, la méthode de la sécante est assez semblabe à celle de Newton, mais on remplace $f'(x_n)$ par $\frac{f(x_n)-f(x_{n-1})}{x_n-x_{n-1}}$. Il n'est pas nécessaire que le zéro de $f$ soit dans l'intervalle $[x_0,x_1]$. \\

\noindent Ainsi, on peut écrire l'algorithme de la méthode de la sécante selon ce pseudo-code :
\begin{verbatim}
Entrée : fun, a, b, tol, iterMax, trueValue
Sortie: approximation de la racine, nombre d'itérations, erreur relative
Step 1 : i ← 1
Step 2 : x0 ← a
Step 3 : x1 ← b
Step 4 : TANT QUE i < iterMax ET |x1 - x0| > tol FAIRE
Step 5 :    i ← i + 1
Step 6 :    x2 ← x1 - fun(x1)*(x1 - x0)/(fun(x1) - fun(x0))
Step 7 :    x0 ← x1
Step 8 :    x1 ← x2
Step 9 : FIN TANT QUE
Step 10 : xfinal ← x1
Step 11 : err ← |xfinal - trueValue|
\end{verbatim}
\noindent Après avoir utilisé cet algorithme pour trouver le zéro (connu comme étant environ $1,36523$) de la fonction $f(x) = x^3 + 4x^2 -10$, avec $a=0$ et $b=5$, avec pour tolérance $10^-3$ et en limitant les itérations à $100$, nous obtenons :
\begin{itemize}
    \item Approximation de la racine : $1,3652$
    \item Nombre d'itérations : $10$
    \item Puissance de l'erreur : $10^-7$
    \item Temps moyen d'exécution (sur 100 exécutions) : $0,541$ ms
\end{itemize}
Nous pouvons donc en conclure que l'algorithme converge bien vers une approximation de la racine de $f$.

% ===== Fausse pos =====
\subsection{Méthode de la fausse position}
\label{ref:fausse-position}
\noindent La méthode de la fausse position est semblable à celle de de Newton et de la sécante, mais apporte une subtilité. Dans la méthode de la sécante, le zéro de la fonction n'est pas nécessairement encadré par les valeurs $x_0$ et$x_1$. La méthode de la fausse position fait intervenir une redéfinition des bornes à chaque itération pour toujours encadrer le zéro.\\

\noindent Ainsi, on peut écrire l'algorithme de la fausse position selon ce pseudo-code :
\begin{verbatim}
Entrée : fun, a, b, tol, iterMax, trueValue
Sortie: approximation de la racine, nombre d'itérations, erreur relative
Step 1 : i ← 1
Step 2 : x0 ← a
Step 3 : x1 ← b
Step 4 : TANT QUE i < iterMax
Step 5 :    i ← i + 1
Step 6 :    (x0*fun(x1) - x1*fun(x0))/(fun(x1) - fun(x0))
Step 7 :    SI |fun(x2)| < tol
Step 8 :        BREAK
Step 9 :    FIN SI
Step 10 :   SI fun(x0) * fun(x2) < 0
Step 11 :       x1 ← x2
Step 12 :   SINON
Step 13 :       x0 ← x2
Step 14 :   FIN SI
Step 15 : FIN TANT QUE
Step 16 : xfinal ← x2
Step 17 : err ← |xfinal - trueValue|
\end{verbatim}
\noindent Nous prenons le parti de définir \texttt{fun(x2) < 0} comme condition d'arrêt relative à la tolérance.\\
\noindent Après avoir utilisé cet algorithme pour trouver le zéro (connu comme étant environ $1,36523$) de la fonction $f(x) = x^3 + 4x^2 -10$, avec $a=0$ et $b=5$, avec pour tolérance $10^{-3}$ et en limitant les itérations à $100$, nous obtenons :
\begin{itemize}
    \item Approximation de la racine : $1,3652$
    \item Nombre d'itérations : $33$
    \item Puissance de l'erreur : $10^{-5}$
    \item Temps moyen d'exécution (sur 100 exécutions) : $0,502$ ms
\end{itemize}
Nous pouvons donc en conclure que l'algorithme converge bien vers une approximation de la racine de $f$.



% Résultats ---------------------------------------------------
\section{Résultats}
\label{ref:resultats}
\noindent On regroupe les résultats obtenus pour la recherche de zéro de la fonction $f(x) = x^3 + 4x^2 -10$ dans le tableau \ref{table1} :
\begin{table}[H]
    \centering
    \begin{tabularx}{\linewidth}{|l|X|X|X|X|}
        \hline
        \textbf{Méthode} & \textbf{Résultat} & \textbf{Nb Itérations} & \textbf{Vitesse moyenne} & \textbf{Puissance erreur} \\
        \hline
        \textbf{Dichotomie} & $1,3654$ & 13 & $0,324$ ms & $10^{-4}$ \\
        \hline
        \textbf{Trichotomie} & $1,3653$ & 8 & $0,285$ ms & $10^{-5}$ \\
        \hline
        \textbf{Point fixe} & $1,3654$ & 10 & $0,439$ ms & $10^{-4}$ \\
        \hline
        \textbf{Newton} & $1,3653$ & 5 & $0,183$ ms & $10^{-5}$ \\
        \hline
        \textbf{Sécante} & $1,3652$ & 10 & $0,502$ ms & $10^{-7}$ \\
        \hline
        \textbf{Fausse position} & $1,3652$ & 33 & $0,541$ ms & $10^{-5}$ \\
        \hline
    \end{tabularx}
    \caption{Résultats pour la fonction $f(x) = x^3 + 4x^2 -10$}
    \label{table1}
    \label{tab:tableau}
\end{table}
\noindent Ce tableau nous permet d'observer que la méthode nécessitant le moins d'itérations pour converger est la méthode de Newton. Toutefois, elle n'offre pas la meilleure précision puisque la méthode de la sécante approche la fonction à $10^{-7}$ près.\\
La comparaison entre les méthodes de dichotomie et trichotomie (basées sur le même fonctionnement) montre que la trichotomie est plus rapide à converger et plus précise.\\
La méthode qui semble la moins efficace est la méthode de la fausse position avec ses 33 itérations.




% Discussions ---------------------------------------------------
\section{Discussions}
\label{ref:discussions}
\subsection{Autour de la trichotomie}
\subsection{Comparaison des méthodes}


% Conclusion ---------------------------------------------------
\section{Conclusion}



% Page X Références -------------------------------------------------------
\section{Références}
\label{ref:Références}
\begin{itemize}
    \item \textbf{Source 1:} Méthode de Newton. (2023, avril 13). Dans \textit{Wikipédia}. Récupéré le 18 mai 2023, de \url{https://fr.wikipedia.org/wiki/M%C3%A9thode_de_Newton}
    
    \item \textbf{Source 2:} Point fixe. (2023, avril 13). Dans \textit{Wikipédia}. Récupéré le 18 mai 2023, de \url{https://fr.wikipedia.org/wiki/Point_fixe}
    
    \item \textbf{Source 3:} Albera, L. (2023). Module de mathématiques CUPGE1 ESIR.
\end{itemize}

\end{document}